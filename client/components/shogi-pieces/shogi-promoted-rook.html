<link rel="import" href="../shogi-piece/shogi-piece.html">

<dom-module id="shogi-promoted-rook">
    <script>
        (function(){
            'use strict';

            class ShogiPromotedRook extends ShogiPiece {

                static get is() { return 'shogi-promoted-rook'; }
                static get config() {
                    return {
                        properties: {
                            kanji: { value: '龍王' },
                            romaji: { value: 'Ryūō' },
                            english: { value: 'Promoted Rook' },
                            side: { type: String },
                            promoted: { type: Boolean, value: true, reflectToAttribute: true }
                        }
                    }
                }

                constructor() {
                    super();
                }

                connectedCallback() {
                    super.connectedCallback();
                    this.setAttribute('title', `${this.english} | ${this.kanji} | ${this.romaji}`);
                }

                /**
                 * {|, |, |, |, #, |, |, |, |}
                 * {|, |, |, |, #, |, |, |, |}
                 * {|, |, |, |, #, |, |, |, |}
                 * {|, |, |, #, #, #, |, |, |}
                 * {#, #, #, #, X, #, #, #, #}
                 * {|, |, |, #, #, #, |, |, |}
                 * {|, |, |, |, #, |, |, |, |}
                 * {|, |, |, |, #, |, |, |, |}
                 * {|, |, |, |, #, |, |, |, |}
                 */
                theoreticalMoves(y, x) {
                    var possible = [];
                    var possibleFiltered = [];

                    // To Top
                    let xc = x, yc = y;
                    for (var i = 0; i < 8; i++)  possible.push({ y: yc++, x: xc });

                    // To Bottom
                    xc = x, yc = y;
                    for (var i = 0; i < 8; i++) possible.push({ y: yc--, x: xc });

                    // To Left
                    xc = x, yc = y;
                    for (var i = 0; i < 8; i++) possible.push({ y: yc, x: xc++ });

                    // To Right
                    xc = x, yc = y;
                    for (var i = 0; i < 8; i++) possible.push({ y: yc, x: xc-- });

                    // Filter out all invalid moves.
                    for(let move of possible) {
                        if(move.x >= 0 && move.y >= 0 && move.x < 9 && move.y < 9)
                            if(move.y !== y || move.x !== x)
                                possibleFiltered.push(move);
                    }

                    return possibleFiltered;
                }

                promotedMoves(y, x) {
                    let possible = [
                        { y: y-1, x: x-1 },
                        { y: y+1, x: x+1 },
                        { y: y-1, x: x+1 },
                        { y: y+1, x: x-1 }
                    ];
                    let possibleFiltered = [];

                    for(let move of possible) {
                        if(move.x >= 0 && move.y >= 0 && move.x < 9 && move.y < 9)
                            if(move.y !== y || move.x !== x)
                                possibleFiltered.push(move);
                    }

                    return possibleFiltered;
                }

                possibleMoves(y, x, vboard) {
                    let moves = this.theoreticalMoves(y, x);
                    let filteredMoves = [];
            
                    let NBlocked = false;
                    let SBlocked = false;
                    let EBlocked = false;
                    let WBlocked = false;

                    for(let move of moves) {
                        let piece = vboard.layout[move.y][move.x];

                        // Check for black piece.
                        if(this.side === 'black') {

                            // Check North
                            if(move.y < y && !NBlocked) {
                                let canAdd = true;

                                if(BoardHelper.IsBlackPiece(piece, vboard)) {
                                    NBlocked = true;
                                    canAdd = false;
                                }

                                if(BoardHelper.IsWhitePiece(piece, vboard)) NBlocked = true;
                                if(canAdd) filteredMoves.push(move);
                            }

                            // Check South
                            if(move.y > y && !SBlocked) {
                                let canAdd = true;

                                if(BoardHelper.IsBlackPiece(piece, vboard)) {
                                    SBlocked = true;
                                    canAdd = false;
                                }

                                if(BoardHelper.IsWhitePiece(piece, vboard)) SBlocked = true;
                                if(canAdd) filteredMoves.push(move);
                            }

                            // Check East
                            if(move.x < x && !EBlocked) {
                                let canAdd = true;

                                if(BoardHelper.IsBlackPiece(piece, vboard)) {
                                    EBlocked = true;
                                    canAdd = false;
                                }

                                if(BoardHelper.IsWhitePiece(piece, vboard)) EBlocked = true;
                                if(canAdd) filteredMoves.push(move);
                            }

                            // Check West
                            if(move.x > x && !WBlocked) {
                                let canAdd = true;

                                if(BoardHelper.IsBlackPiece(piece, vboard)) {
                                    WBlocked = true;
                                    canAdd = false;
                                }

                                if(BoardHelper.IsWhitePiece(piece, vboard)) WBlocked = true;
                                if(canAdd) filteredMoves.push(move);
                            }

                        }

                        // Check for white piece.
                        if(this.side === 'white') {
                        
                            // Check North
                            if(move.y < y && !NBlocked) {
                                let canAdd = true;

                                if(BoardHelper.IsWhitePiece(piece, vboard)) {
                                    NBlocked = true;
                                    canAdd = false;
                                }

                                if(BoardHelper.IsBlackPiece(piece, vboard)) NBlocked = true;
                                if(canAdd) filteredMoves.push(move);
                            }

                            // Check South
                            if(move.y > y && !SBlocked) {
                                let canAdd = true;

                                if(BoardHelper.IsWhitePiece(piece, vboard)) {
                                    SBlocked = true;
                                    canAdd = false;
                                }

                                if(BoardHelper.IsBlackPiece(piece, vboard)) SBlocked = true;
                                if(canAdd) filteredMoves.push(move);
                            }

                            // Check East
                            if(move.x < x && !EBlocked) {
                                let canAdd = true;

                                if(BoardHelper.IsWhitePiece(piece, vboard)) {
                                    EBlocked = true;
                                    canAdd = false;
                                }

                                if(BoardHelper.IsBlackPiece(piece, vboard)) EBlocked = true;
                                if(canAdd) filteredMoves.push(move);
                            }

                            // Check West
                            if(move.x > x && !WBlocked) {
                                let canAdd = true;

                                if(BoardHelper.IsWhitePiece(piece, vboard)) {
                                    WBlocked = true;
                                    canAdd = false;
                                }

                                if(BoardHelper.IsBlackPiece(piece, vboard)) WBlocked = true;
                                if(canAdd) filteredMoves.push(move);
                            }
                        }
                    }

                    let promotedMoves = this.promotedMoves(y, x);

                    for(let move of promotedMoves) {
                        let piece = vboard.layout[move.y][move.x];

                        if(this.side === 'white') {
                            if(BoardHelper.IsBlackPiece(piece, vboard) || piece === 0) {
                                filteredMoves.push(move)
                            }
                        }

                        if(this.side === 'black') {
                            if(BoardHelper.IsWhitePiece(piece, vboard) || piece === 0) {
                                filteredMoves.push(move)
                            }
                        }

                    }

                    return filteredMoves;
                }
            }

            customElements.define(ShogiPromotedRook.is, ShogiPromotedRook);
        })();
    </script>
</dom-module>